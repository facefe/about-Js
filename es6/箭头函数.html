<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 主要是箭头函数
        // let f = v => v; // 简单的写法
        // console.log(f(123))


        // === let function v(){ return v  }
        //
        // // let f = () => 5
        //
        // // console.log(f())
        //
        // // let sum = (n1, n2) => n1 + n2;
        //
        // // 1 如果箭头函数不需要参数 或者 需要多个参数 就用(  )  括起来
        //
        // // 2 如果箭头函数的代码块 需要多于一条语句，就用 大括号括起来，并且 用retrun
        //
        // // 3 如果箭头函数需要返回一个对象，需要用() 小括号 括起来返回。
        //
        // // console.log(sum(2, 3))
        //
        // // let full = ({
        // //     first,
        // //     last
        // // }) => {
        // //     return first + ' ' + last
        // // }
        //
        // // var a = {
        // //     first: 2,
        // //     last: 3
        // // }

        // // 与结构赋值结合使用
        // // var b = full(a)
        // // console.log(b)
        //
        //
        // // 与rest 参数相结合
        // // rest 是一个数组，因此rest参数可以应用数组的方法。 接受函数的多余变量。
        //
        //
        // // 发现 let 定义的变量竟然不归window所有。
        //
        // // 箭头函数的三点注意事项：
        // /*
        // 1:箭头函数中的this 就是箭头函数被定义时候的指向。而不是使用时所在的指向。
        // 2:箭头函数不可以当作构造函数。
        // 3:箭头函数不存在arguments 对象。可以用rest 代替。
        // 4:不存在yield 不可以用作Generator .
        //
        // */
        //
        // function foo() {
        //     setTimeout(() => {
        //         console.log(this.id)
        //     }, 1000)
        // }
        // let id = 1000; // 如果用let 定义因为不归window 所以下面会打印 undefined
        //
        // foo.call({
        //     id: 1999
        // });
        //
        // foo.apply({
        //     id: '我不知道会打印什么'
        // });
        // foo()
        // // 好像全部都绑定上了。
        // //箭头函数可以让this 的指向固定化。
        //
        // //箭头函数没有this 的原因是因为箭头函数根本就没有自己的this ,所以this 就是指向外层的this
        //
        // // 箭头函数的this es5的写法。
        //
        // function foocopy() {
        //     var _this = this;
        //     setTimeout(function () {
        //         console.log(_this.id)
        //     }, 1000)
        // }
        // // 表明箭头函数没有自己的this。、
        // // 此外箭头函数还没有
        // // arguments
        // // super
        // // new.target
        // // 这三个变量全部指向外层函数的 相应变量。
        //
        // foocop = function () {
        //     setTimeout(() => {
        //         console.log(arguments)
        //     }, 100)
        // };
        //
        // foocop(1, 2, 3, 4, 5);
        //
        // //表明箭头函数没有arguments
        //
        // // 因为箭头函数没有自己的this 所以就不能使用call() apply() bind() 改变this 指向。
        //
        // function insert(value) {
        //     return {
        //         into: function (arr) {
        //             return {
        //                 after: function (aftervalue) {
        //                     arr.splice(arr.indexOf(aftervalue) + 1, 0, value)
        //                     return arr
        //                 }
        //             }
        //         }
        //     }
        // }
        // // 这也是一个运用了闭包的函数，但是他没有明显的讲内部变量保存出来。
        // // 还是好几层闭包。
        //
        // var ar = insert(2).into([1, 3]).after(1)
        // console.log(ar)
        //
        // // 用箭头函数改写
        //
        // let inser = (value) => ({
        //     into: (arr) => ({
        //         after: (aftervalue) => {
        //             arr.splice(arr.indexOf(aftervalue) + 1, 0, value);
        //             return arr
        //
        //         }
        //     })
        // });
        // //简单了吗？？？
        // var ar = inser(2).into([1, 3]).after(1);
        // console.log(ar);
        // // 尾调用
        // // 函数式编程的一种方法。
        // function f() {
        //     return g()
        //     // 只函数的最后一步是调用某个函数。
        // }
        //
        // function m() {
        //     if (true) {
        //         gx()
        //     }
        //     px()
        // }
        //
        // // 只有尾调用中不在用到 此函数所在作用域中的变量,才会称之为尾调用。
        //
        // // 其实就是函数的栈操作, 最外层的函数在 栈是最底层，最里面的函数在上面，然后上面的函数先执行。
        // function addOne(x) {
        //     let one = 1
        //
        //     function inner(y) {
        //         return y + one
        //     }
        //     return inner(x)
        //     //
        //     // 不属于尾调用，因为 用到   one
        // }
        //
        // // 比较明显的是 递归容易消耗 很大的内存。
        // function fu(x = 9) {
        //     console.log(x)
        //
        // }
        //
        //
        //
        // function view(x = 9) {
        //     var x = 9999
        //     console.log(x)
        // }
        //
        // function viewe(x = 9) {
        //     let x = 999
        //
        // }
        // view(); //不报错
        // viewe() // 报错
    </script>
</body>

</html>