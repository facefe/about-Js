<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <link rel="stylesheet" type="text/css" media="screen" href="main.css" /> -->
    <!-- <script src="main.js"></script> -->
</head>

<body>
    <script>
        // 面向对象的程序设计
        // ECMAScript 中含有两种属性：数据属性和访问器属性
        // 数据属性
        // [[Configurable]]:表示能否通过delete 删除属性，修改属性值 或者 更改为访问器属性，默认为true
        // Configurable 是表示可配置性。如果configurable 设置为false ,
        // 则表示 属性不可以配置。再修改 例如 Enumerable 就会报错，但是如果Writable 设置为true ,可以设置为false ,但是之后就是不可修改的。
        // [[Enumerable]]:能否通过 for in 循环返回属性默认为true
        // [[Writeable]] :能否修改属性值 默认为true
        // [[Value]]:属性值 ，默认为undefined

        // 上面这些属性是可以修改的、Object.defineProperty()
        // 接受三个参数：属性所在对象，属性名字，和属性描述符(可以设置一个或者两个，三个)。

        /* var person = {}
         Object.defineProperty(person, 'name', {
             writable: false,
             // false 不能字符串 'false' 
             enumerable: true,
             configurable: true,
             value: '小雨'

         })

         console.log(person.name)
         person.name = '小张'

         //严格模式下，writable:false  为person 赋值会报错， 剩下的两个属性也相同，设置为false ,在进行操作，会报错。但是非严格模式下，什么也不会发生。

         console.log(person.name)

         person.name = 'xiao liu '
         console.log(person.name)
         person.name = null
         //赋值给null 也不可以
         console.log(person.name)
         for (let i in person) {
             console.log('我是' + person.name)
         }

         // Object.defineProperty(person,'')
         //默认情况下调用 Object.defineProperty()方法，创建新属性，默认writavle,enumeravle,confgurable 都为false

         // 访问器属性：
         // 如果属性中很有get 或者set 函数。就会被定义为访问器属性。
         // 设置为访问器属性后wratable 和value 值会被忽略。
         // 但是下面两个属性依旧可以被设置。
         // [[Configurable]]:是否可以delete
         // [[Enumerable]] : 能否for in 循环

         // [[Get]] 读取属性时，调用的函数
         // [[Set]] 设置属性是，调用的属性

         var book = {
             _year: 2004,
             edition: 1
         }

         Object.defineProperty(
             book, 'year', {
                 get: function () {
                     return this._book
                 },
                 set: function (newvalue) {
                     if (newvalue > 2004) {
                         this._book = newvalue
                         this.edition += newvalue - 2004
                     }
                 }
             }
         )

         book.year = 2009
         var edition = book.edition
         console.log(edition)*/


        let myObj = {
            get a() {
                return 4
            },
            set a(val) {
                this._a_ = val
            }
        }
        let scries = Object.getOwnPropertyDescriptor(myObj, 'a')
        console.log(scries)


        let ar = {
            aa: 1
        }
        Object.defineProperty(ar, 'aa', {
            configurable: false,
            value: '4',
            writable: true,
            enumerable: true
        })
        /* Object.defineProperty(ar, 'aa', {
             value: '43',
             writable: false,
             configurable: true,
             enumerable: true
         })?
         在设置属性属性描述是，当configurable 为false 时候 之后 的configurable h和enumerable 就是不可以改变的
         否则会报错。但是如果之前writable 是true 的话。可以改为false 但是之后不能改变了。
         而且 configuravle 还会禁止删除这个属性*/
        for (let i in ar) {
            console.log(i)
        }

        // 禁止扩展 
        // preventExtensuons()
        let pObj = {}
        Object.preventExtensions(pObj)
        pObj.a = 234;
        'use strict'
        // 在严格模式下配置不可变的属性会报错，但是这里还是没有。
        console.log(pObj.a) // undefined 太厉害了这个属性
        // Object.seal()
        // 会密封所有属性，实际是调用 Object.preventExtensions() 并将所有属性的configurable 设置为false.

        // 冻结 Object.freeze()
        // 最高的级别的不可变，实际上是调用 Object.seal() 并将所有的writable 设置为false

        // 几种方法
        // hasOwnProperty()  判断实例上是否存在某个属性。
        // 注意这个方法是存在 Object.property 上。所以如果 对象的原型链被改写，或者没有原型链 就会导致没有这个方法。


        for (let i in Object.prototype) {
            console.log(i)
        }
        // 原型链上的属性应该是不可以枚举的
        for(let i in Object){
            console.log(i)
        }
    </script>

</body>

</html>